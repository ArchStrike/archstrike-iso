#!/usr/bin/env python
""" Write resolvable packages in archstrike group to stdout and summarize irresolvable to stderr

Example usage:
    $ resolve_archstrike_group <path>/<to>/archstrike-iso/configs/openbox/packages.both
Through the example usage both the archstrike group and `../configs/openbox/packages.both` are inspected for
 * packages that cannot be found or have a dependency that cannot be found
 * conflicts between two packages such that any package in their dependency tree conflicts with a dependency in the other tree
"""
import sys
import pyalpm
import pycman
import logging
import collections
logging.basicConfig(format='%(message)s', level=logging.DEBUG, handlers=[logging.NullHandler()])
stdout = logging.getLogger('stdout')
stdout.addHandler(logging.StreamHandler(sys.stdout))
stderr = logging.getLogger('stderr')
stderr.addHandler(logging.StreamHandler(sys.stderr))


sep = " " * 4


class FlatDepends(object):
    def __init__(self):
        self.conflicts = set([])
        self.depends = set([])


flatdepends = collections.defaultdict(FlatDepends)


def get_packages_depending_on(flatdepends, pkgname):
    return [pkg for pkg, info in flatdepends.items() if pkgname in info.depends]
    

def get_group_packages(repos, name):
    for repo in repos.values():
        grp = repo.read_grp(name)
        if grp is None:
            continue
        name, pkgs = grp
        return pkgs


def find_satisfier(repos, pkg):
    for syncdb in repos.values():
        satisfier = pyalpm.find_satisfier(syncdb.pkgcache, pkg)
        if satisfier is not None:
            return satisfier


def find_missing_depends(repos, root, deps):
    global flatdepends
    missing = set([])
    for dep in deps:
        flatdepends[root].depends.add(dep)
        satisfier = find_satisfier(repos, dep)
        if satisfier is None:
            missing.add(dep)
            continue
        for replaced in satisfier.replaces:
            flatdepends[root].depends.add(replaced)
        for provided in satisfier.provides:
            flatdepends[root].depends.add(provided)
        for conflict in set(satisfier.conflicts) - flatdepends[root].depends:
            flatdepends[root].conflicts.add(conflict)
        recurse_deps = [d for d in satisfier.depends if d not in flatdepends[root].depends]
        for subtree_dep in find_missing_depends(repos, root, recurse_deps):
            missing.add(subtree_dep)
    return missing


def irresolvable_depends(repos, pkgs):
    for pkg in pkgs:
        missing_depends = find_missing_depends(repos, pkg.name, pkg.depends)
        if missing_depends:
            yield pkg.name, missing_depends


def irresolvable_depends_from_file(repos, filename):
    if filename is None:
        return
    for line in open(filename):
        line = line.strip()
        if line.startswith('#') or len(line) == 0:
            continue
        for pkgname in line.split(' '):
            okay, pkg = pycman.action_sync.find_sync_package(pkgname, repos)
            if not okay:  # make sure not a group before saying it's missing
                grp_pkgs = get_group_packages(repos, pkgname)
                if grp_pkgs:
                    for pkgname, deps in irresolvable_depends(repos, grp_pkgs):
                        yield pkgname, deps
                else:
                    yield pkgname, [f'(error: {pkg})']
            else:
                missing_deps = find_missing_depends(repos, pkg.name, pkg.depends)
                if missing_deps:
                    yield pkg.name, missing_deps


def conflicting_pactrees(flatdepends):
    package_conflicts = collections.defaultdict(set)
    for pkg_i, flatdep_i in flatdepends.items():
        for pkg_j, flatdep_j in flatdepends.items():
            if pkg_i == pkg_j:
                continue
            deps_i = flatdep_i.depends
            conflicts_j = flatdep_j.conflicts
            conflicted = False
            if pkg_i in conflicts_j:
                package_conflicts[pkg_i].add(pkg_j)

            for conflict in deps_i.intersection(conflicts_j):
                package_conflicts[pkg_j].add(pkg_i)
                package_conflicts[conflict].add(pkg_i)
    return package_conflicts


def column_width(lhs_title, values):
    width = len(lhs_title)
    for val in values:
        width = max(width, len(val))
    return width


def show_resolvable_packages(pkgs, irresolvable):
    exclusions = set([])
    for pkg, missing_deps in irresolvable.items():
        exclusions.add(pkg)
        for dep in missing_deps:
            exclusions.add(dep)
    stdout.info(' '.join([pkg.name for pkg in pkgs if pkg.name not in exclusions]))
    stderr.error("")


def show_irresolvable_depends(pkg_missing_depends, origin, rhs="Package depends"):
    if not pkg_missing_depends:
        return
    # Find padding
    lhs = f"Irresolvable {origin}"
    width = column_width(lhs, pkg_missing_depends) + len(sep)
    # Header
    stderr.error(f"{lhs:<{width}}{rhs}")
    for pkg, missing_depends in pkg_missing_depends.items():
        err_depends = " ".join(missing_depends)
        stderr.error(f"\033[1;31m{pkg:<{width}}{err_depends}\033[m")
    stderr.error("")


def main(packages_file):
    # Init
    config_file = "/etc/pacman.conf"
    pacman_config = pycman.config.PacmanConfig(conf=config_file)
    hpacman = pacman_config.initialize_alpm()
    dbnames = set(['core', 'extra', 'community', 'multilib', 'archstrike', 'archstrike-testing'])
    repos = dict((db.name, db) for db in hpacman.get_syncdbs() if db.name in dbnames)
    # Find bad packages for group/file
    pkgs = get_group_packages(repos, 'archstrike')
    bad_group_pkgs = {pkg: missing for pkg, missing in irresolvable_depends(repos, pkgs)}
    bad_file_pkgs = {pkgname: err for pkgname, err in irresolvable_depends_from_file(repos, packages_file)}
    # Find conflicted trees
    conflicted_trees = conflicting_pactrees(flatdepends)
    # Create exclusion list
    bad_pkgs = {}
    bad_pkgs.update(bad_group_pkgs)
    bad_pkgs.update(bad_file_pkgs)
    # Show results
    show_resolvable_packages(pkgs, bad_pkgs)
    show_irresolvable_depends(bad_group_pkgs, "archstrike")
    show_irresolvable_depends(bad_file_pkgs, "file")
    show_irresolvable_depends(conflicted_trees, "tree", "Conflicts")


if __name__ == "__main__":
    packages_file = sys.argv[1] if len(sys.argv) == 2 else None
    main(packages_file)
